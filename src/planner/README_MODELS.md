# Supply Chain Planning Engine (SCPE)

## üìã Estructura de Modelos Completada (Todo #1)

### 1. **Modelo de Maestro de √çtems** (`models/items.py`)

**Clases implementadas:**

#### `ItemMaster`
Maestro completo de material con:

- **Identificadores**: item_id, sap_code, descripci√≥n
- **Clasificaci√≥n ABC**: A (80% valor), B (15%), C (5%)
- **Criticidad**: CRITICAL, HIGH, MEDIUM, LOW
- **Tipo de abastecimiento**: PURCHASE, MAKE, TRANSFER, IMPORT, VMI
- **Unidades de medida**: Base + alternativas con factores conversi√≥n
- **Especificaciones t√©cnicas**: Dict flexible para tensi√≥n, RPM, etc.
- **Cumplimiento normativo**:
  - `requires_traceability`: bool
  - `compliance_standards`: ISO, FDA, etc.
  - `shelf_life_days`: None = indefinida
  - `requires_cold_chain`: bool
- **Estructura de producto**:
  - `is_assembly`: bool
  - `bom: List[BOMComponent]` con factores de desperdicio
- **√çtems equivalentes** (`equivalent_items: List[EquivalentItem]`):
  - Conversi√≥n t√©cnica
  - Factor de costo diferencial
  - Confiabilidad del proveedor
- **Par√°metros de control**:
  - MOQ (Minimum Order Quantity)
  - Order m√∫ltiplo (ej: pallets)
  - D√≠as de stock de seguridad
- **Costos**: Standard cost, list price, consumo anual estimado

**M√©todos principales:**
```python
get_quantity_in_base_unit(quantity, from_unit) -> float
```

#### `BOMComponent` 
Componente en lista de materiales:
- component_id, quantity, UoM
- Secuencia de ensamble
- scrap_factor (1.05 = 5% desperdicio)

#### `EquivalentItem`
√çtem equivalente:
- Conversi√≥n t√©cnica (factor de equivalencia)
- % coincidencia de specs (0-1)
- Diferencial de costo (+5%, -10%)
- Delta de lead time
- Confiabilidad del proveedor

#### `UnitOfMeasure`
Unidad de medida:
- code: "EA", "KG", "M", "LT"
- Categor√≠a: peso, longitud, cantidad
- Factor de conversi√≥n a UoM base

---

### 2. **Modelo de Inventario** (`models/inventory.py`)

#### `InventoryLot`
Lote √∫nico con trazabilidad completa:

- **Identificaci√≥n**: lot_number, serial_number, item_id
- **Cantidades**:
  - `quantity_received`: Recibida
  - `quantity_on_hand`: Disponible en almac√©n
  - `quantity_reserved_hard`: Reservas confirmadas
  - `quantity_reserved_soft`: Reservas tentativas
  - `quantity_allocated`: Asignadas a SO (salidas)
  - **Propiedad**: `quantity_available` = QoH - reservas - allocated
- **Fechas**:
  - receipt_date
  - expiration_date (None = no aplica)
  - shelf_life_days
- **Control de Calidad (QC)**:
  - Status: INSPECTING, APPROVED, CONDITIONAL, REJECTED, QUARANTINE
  - qc_approver, qc_date, qc_notes
- **Ubicaci√≥n f√≠sica**: `locations: List[LotLocation]`
  - Warehouse, Zone, Rack, Level, Position
  - M√©todo: `full_location()` ‚Üí "ALM-1-REC-2-A1"
- **Trazabilidad**:
  - supplier_id, purchase_order, invoice_number
- **Propiedades computed**:
  - `is_expired`: ¬øVencido?
  - `days_to_expiration`: D√≠as para expiraci√≥n
  - `is_critical_expiration(threshold_days=30)`: ¬øPr√≥ximo a vencer?

#### `LotLocation`
Ubicaci√≥n f√≠sica:
- warehouse_code, zone, rack, level, position
- M√©todo: `full_location()` para ubicaci√≥n formateada

#### `InventorySnapshot`
Fotograf√≠a de inventario en un momento:

- **Totales por almac√©n e √≠tem**:
  - total_on_hand
  - total_reserved_hard/soft
  - total_allocated
- **Salud**:
  - expired_quantity
  - critical_expiration_quantity
  - quality_hold_quantity
- **Distribuci√≥n por lote**: `lots: List[InventoryLot]`
- **An√°lisis FEFO**:
  - M√©todo: `get_allocation_sequence_fefo()` ‚Üí Lotes ordenados por expiraci√≥n FIFO
- **Propiedad**: `quantity_available` = total_on_hand - reservas - expirados - hold

---

### 3. **Modelo de Lead Times** (`models/lead_times.py`)

#### `LeadTimeDistribution`
Distribuci√≥n probabil√≠stica N(Œº, œÉ¬≤):

- **Par√°metros**:
  - mean_days (Œº)
  - std_dev_days (œÉ)
  - min_days, max_days (l√≠mites realistas)
- **Percentiles**:
  - p50_days (mediana)
  - p95_days (95% servicio)
  - p99_days (peor caso)
- **Confianza**:
  - confidence_level (0-1)
  - sample_size (# de observaciones)

**M√©todos:**
- `calculate_service_level_lead_time(service_level=0.95)`:
  - Retorna LT para nivel de servicio usando Z-score de distribuci√≥n normal
- `update_with_observation(actual_lead_time_days, weight)`:
  - Actualizaci√≥n bayesiana simplificada de la media

#### `LeadTimeHistory`
Hist√≥rico de entregas:

- PO, fecha prometida, fecha real
- Varianza en d√≠as (positivo = retraso)
- on_time: bool
- Cantidad entregada vs. short
- Quality issues
- Propiedades computed:
  - `variance_days`: Auto-calculado
  - `on_time`: Auto-validado vs. promised_date

#### `LeadTimeEstimate`
Estimaci√≥n agregada por ruta/proveedor:

- item_id, supplier_id, sourcing_path (STOCK, PURCHASE, IMPORT, etc.)
- distribution: LeadTimeDistribution
- historical_data: List[LeadTimeHistory]
- on_time_percentage (hist√≥rico)
- last_updated

**M√©todos:**
- `get_recommended_lead_time(service_level=0.95)`: LT para nivel de servicio
- `add_observation(history)`: Agregar hist√≥rico y actualizar distribuci√≥n

---

### 4. **Modelo de Capacidades** (`models/capacity.py`)

#### `ResourceCapacity`
Capacidad de un recurso (proveedor, almac√©n, transporte):

- **Identificaci√≥n**:
  - resource_id, resource_type (SUPPLIER, WAREHOUSE, CUSTOMS)
  - capacity_type (SUPPLIER_CAPACITY, WAREHOUSE_CAPACITY, TRANSPORT_CAPACITY, CASH_FLOW, etc.)
- **Capacidad**:
  - capacity_value (disponible)
  - capacity_unit (kg, piezas, m¬≥, USD, etc.)
- **Ocupaci√≥n**:
  - reserved_value (reservado)
  - allocated_value (asignado)
  - Propiedad: `available_capacity` = value - reserved - allocated
  - Propiedad: `utilization_percentage` (0-100%)
- **Ventanas de disponibilidad**: available_from, available_until
- **Metadata**: updated_at, notes

**M√©todos:**
- `can_allocate(required_value)` ‚Üí bool
- `allocate(value, is_hard=True)` ‚Üí bool
- `release(value, is_hard=True)` ‚Üí None

#### `CapacityConstraint`
Restricci√≥n de capacidad en una solicitud:

- solicitud_id, resource_id
- required_value, capacity_unit
- Ventanas: required_by_date, latest_possible_date
- priority (1=cr√≠tica, 1000=baja)
- is_satisfied, satisfaction_date
- M√©todo: `mark_satisfied()` ‚Üí Marcar como cumplida

---

### 5. **Modelo de Opciones de Abastecimiento** (`models/sourcing.py`)

#### `SourcingOption`
Opci√≥n √∫nica de abastecimiento:

- **Identificaci√≥n**:
  - option_id: "item_id:path_type:supplier_id"
  - sourcing_path: STOCK_LOCAL, PURCHASE, IMPORT, DISASSEMBLY, EQUIVALENT, TRANSFER, etc.
  - supplier_id (None para stock local)
- **Especificaciones**:
  - quantity_available
  - unit_of_measure
- **Costos**:
  - unit_cost_usd
  - transportation_cost_usd
  - customs_duty_usd
  - handling_cost_usd
  - Propiedad: `total_cost_per_unit` = suma de todos
- **Lead Time**:
  - lead_time_days_mean
  - lead_time_days_std
  - lead_time_days_p95
- **Confiabilidad**:
  - on_time_percentage (0-1)
  - quality_acceptance_rate (0-1)
  - availability_percentage (0-1)
- **Restricciones**:
  - minimum_order_quantity
  - order_multiple
  - maximum_order_quantity
- **Ventanas**:
  - order_deadline
  - delivery_window_start/end
- **Scoring**:
  - competitive_rank (1=mejor)
  - ranking_score (multicriteria, 0-1)
  - feasible: bool
  - feasibility_notes
- **Hist√≥rico**:
  - last_used_date
  - success_rate

#### `SourcingPath`
Ruta completa con opciones jerarquizadas:

- path_id: "solicitud_id:material_id"
- solicitud_id, material_id
- required_quantity, required_date
- options: List[SourcingOption] **ordenadas por preferencia**
  - Orden ideal: stock ‚Üí liberaci√≥n ‚Üí ... ‚Üí compra
- **Resultado**:
  - selected_option_id
  - selected_quantity
  - selected_cost
- **An√°lisis**:
  - total_feasible_quantity
  - total_feasible_cost
  - has_feasible_solution: bool
- **Timeline**:
  - analyzed_at, optimized_at, executed_at

**M√©todos:**
- `add_option(option, rank=None)`: Agregar opci√≥n
- `get_next_viable_option(skip_ids=[])`: Pr√≥xima opci√≥n viable en jerarqu√≠a
- `calculate_total_feasible()`: Calcular totales

---

## üìê Diagrama de Relaciones

```
ItemMaster (1) ‚îÄ‚îÄ‚î¨‚îÄ‚Üí (N) BOMComponent
                  ‚îú‚îÄ‚Üí (N) EquivalentItem
                  ‚îú‚îÄ‚Üí (N) SourcingPath
                  ‚îî‚îÄ‚Üí (N) LeadTimeEstimate

InventorySnapshot (1) ‚îÄ‚îÄ‚Üí (N) InventoryLot
                              ‚îú‚îÄ‚Üí (1) ItemMaster
                              ‚îî‚îÄ‚Üí (N) LotLocation

LeadTimeDistribution ‚îÄ‚îÄ‚îÄ‚îÄ LeadTimeEstimate ‚îÄ‚îÄ‚Üí (N) LeadTimeHistory
                                               ‚îÇ
                                               ‚îî‚îÄ‚Üí ItemMaster + Supplier

SourcingPath (1) ‚îÄ‚îÄ‚Üí (N) SourcingOption
                      ‚îú‚îÄ‚Üí ItemMaster
                      ‚îú‚îÄ‚Üí (0,1) Supplier
                      ‚îî‚îÄ‚Üí LeadTimeEstimate

ResourceCapacity ‚îÄ‚îÄ‚îÄ CapacityConstraint
```

---

## üöÄ Pr√≥ximos Pasos (Todos #2-8)

### ‚úÖ **Todo #1: COMPLETADO**
- Modelos: ItemMaster, BOMComponent, EquivalentItem, UnitOfMeasure
- Modelos: InventoryLot, LotLocation, InventorySnapshot
- Modelos: LeadTimeDistribution, LeadTimeHistory, LeadTimeEstimate
- Modelos: ResourceCapacity, CapacityConstraint
- Modelos: SourcingOption, SourcingPath

### üìã **Todo #2: Filtro T√©cnico-Legal**
Implementar funci√≥n que descarta opciones por:
- Especificaci√≥n t√©cnica (mismatch vs. requirements)
- Norma de cumplimiento (FDA, ISO, etc.)
- Licencia/Configuraci√≥n legal
- Shelf-life insuficiente
- Trazabilidad requerida
- Output: Conjunto factible Of

### üìä **Todo #3: Motor de Scoring**
Calcular CTE (costo + atraso + riesgo):
- Features por opci√≥n
- Reglas de corte
- Ranking por criticidad, on-time, costo

### ‚öôÔ∏è **Todo #4: MIP/ILP**
Formulaci√≥n de portafolio con PuLP

### üå≥ **Todo #5: √Årbol de Decisi√≥n**
Gates operacionales: stock ‚Üí liberaci√≥n ‚Üí compra

### üîß **Todo #6: Algoritmos por V√≠a**
Heur√≠sticas especializadas

### üì° **Todo #7: Event-Driven**
Arquitectura de topics + orquestador

### üìã **Todo #8: Auditor√≠a**
Trazabilidad E2E + gobernanza

---

## üì¶ Estructura de Directorios

```
src/planner/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ items.py              ‚úÖ ItemMaster, BOMComponent, EquivalentItem
‚îÇ   ‚îú‚îÄ‚îÄ inventory.py          ‚úÖ InventoryLot, LotLocation, InventorySnapshot
‚îÇ   ‚îú‚îÄ‚îÄ lead_times.py         ‚úÖ LeadTimeDistribution, LeadTimeHistory
‚îÇ   ‚îú‚îÄ‚îÄ capacity.py           ‚úÖ ResourceCapacity, CapacityConstraint
‚îÇ   ‚îî‚îÄ‚îÄ sourcing.py           ‚úÖ SourcingOption, SourcingPath
‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py           (üìã Todo #2)
‚îú‚îÄ‚îÄ scoring/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py           (üìã Todo #3)
‚îú‚îÄ‚îÄ optimization/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py           (üìã Todo #4)
‚îú‚îÄ‚îÄ rules/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py           (üìã Todo #5)
‚îî‚îÄ‚îÄ events/
    ‚îî‚îÄ‚îÄ __init__.py           (üìã Todo #7)
```

---

## üß™ Ejemplo de Uso (Una vez completados todos los m√≥dulos)

```python
from src.planner.models import ItemMaster, InventorySnapshot, SourcingOption, SourcingPath

# 1. Cargar maestro
item = ItemMaster(
    item_id="MAT-001",
    sap_code="100001",
    description="Rodamiento 6208-2Z",
    base_unit="EA",
    standard_cost_usd=12.50,
    abc_class="B",
    criticality="HIGH"
)

# 2. Verificar inventario
inventory = InventorySnapshot(
    warehouse_code="ALM-1",
    item_id="MAT-001",
    total_on_hand=50.0
)

# 3. Crear opciones de abastecimiento
options = [
    SourcingOption(
        option_id="MAT-001:STOCK_LOCAL:NONE",
        item_id="MAT-001",
        sourcing_path="STOCK_LOCAL",
        quantity_available=50.0,
        unit_of_measure="EA",
        unit_cost_usd=0,  # Ya en stock
        lead_time_days_mean=0
    ),
    SourcingOption(
        option_id="MAT-001:PURCHASE:SUP-001",
        item_id="MAT-001",
        sourcing_path="PURCHASE",
        supplier_id="SUP-001",
        quantity_available=500.0,
        unit_of_measure="EA",
        unit_cost_usd=12.50,
        lead_time_days_mean=14.0,
        on_time_percentage=0.96
    )
]

# 4. Crear ruta de abastecimiento
path = SourcingPath(
    path_id="SOL-001:MAT-001",
    solicitud_id="SOL-001",
    material_id="MAT-001",
    required_quantity=100.0,
    required_date=datetime(2025, 11, 10)
)

for opt in options:
    path.add_option(opt)

# 5. An√°lisis (pr√≥ximos m√≥dulos)
# path = filters.apply_technical_filter(path)
# path = scoring.calculate_cte(path)
# solution = optimization.solve_mip(path)
```

---

## üìö Referencias

- **Pydantic Validation**: https://docs.pydantic.dev/
- **Lead Time Distributions**: An√°lisis de serie temporal + distribuci√≥n normal
- **FEFO Logic**: First Expire, First Out para control de lotes
- **BOM Explosion**: Referencia MRP II (Material Requirements Planning)
